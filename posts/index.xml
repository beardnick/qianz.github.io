<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - </title>
        <link>https://beardnick.github.io/qianz.github.io/posts/</link>
        <description>All Posts | </description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 20 Feb 2025 12:22:43 &#43;0800</lastBuildDate><atom:link href="https://beardnick.github.io/qianz.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Write TCP/IP Stack by Yourself (4): TCP Data Transfer and Four-Way Handshake</title>
    <link>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_4/</link>
    <pubDate>Thu, 20 Feb 2025 12:22:43 &#43;0800</pubDate>
    <author>qianz</author>
    <guid>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_4/</guid>
    <description><![CDATA[Data Transfer Continuing from the previous article, after the connection is established, we begin data transfer.
Data Receiver Here&rsquo;s the implementation:
handleData
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func (s *TcpSocket) handleData(tcpPack *tcpip.TcpPack) (resp *tcpip.IPPack, err error) { if tcpPack.Flags&amp;uint8(tcpip.TcpACK) != 0 { s.]]></description>
</item>
<item>
    <title>Write TCP/IP Stack by Yourself (3): TCP Three-Way Handshake</title>
    <link>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_3/</link>
    <pubDate>Wed, 19 Feb 2025 09:56:13 &#43;0800</pubDate>
    <author>qianz</author>
    <guid>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_3/</guid>
    <description><![CDATA[Data Structures The main data structures of the project and their interactions are shown in the following diagram:
Dotted arrows represent asynchronous calls, implemented using Go&rsquo;s channel mechanism. If you want to implement this in another language, you&rsquo;ll need to use a thread-safe message queue to replace the channels. Network is mainly responsible for reading data packets from TUN, writing to TUN, binding socket and IP port information, and routing network packets to the appropriate socket for processing based on IP port information.]]></description>
</item>
<item>
    <title>Write TCP/IP Stack by Yourself (2): TCP Packet Generation</title>
    <link>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_2/</link>
    <pubDate>Tue, 18 Feb 2025 09:59:00 &#43;0800</pubDate>
    <author>qianz</author>
    <guid>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_2/</guid>
    <description><![CDATA[Data Structures The previous article was relatively simple, so we didn&rsquo;t discuss the data structure design in detail. As the following articles will gradually increase in complexity, let&rsquo;s first introduce the data structure design. Computer networks have a layered structure, and each layer except the physical layer has its corresponding packet structure. From the link layer to the application layer, each layer encapsulates the packet from the next layer, so we design our data structures in a similar nested fashion.]]></description>
</item>
<item>
    <title>Write TCP/IP Stack by Yourself (1): TCP Packet Parsing</title>
    <link>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_1/</link>
    <pubDate>Mon, 17 Feb 2025 15:27:18 &#43;0800</pubDate>
    <author>qianz</author>
    <guid>https://beardnick.github.io/qianz.github.io/posts/write_tcp_ip_stack_by_yourself_1/</guid>
    <description><![CDATA[TunTap Since the Linux kernel controls network interfaces, applications cannot directly use network interfaces to handle network packets. Linux provides the tuntap virtual network interface mechanism to allow users to handle raw network packets at the application layer.
Example of Using TUN TunTap can create two types of virtual network interfaces: TUN and TAP. TAP is a layer 2 network interface that provides MAC frames. TUN is a layer 3 network interface that provides IP packets.]]></description>
</item>
<item>
    <title>linux route basic tutorial</title>
    <link>https://beardnick.github.io/qianz.github.io/posts/route/</link>
    <pubDate>Sun, 07 Jul 2024 06:06:52 &#43;0800</pubDate>
    <author>qianz</author>
    <guid>https://beardnick.github.io/qianz.github.io/posts/route/</guid>
    <description><![CDATA[ip rule and ip route the packet is first matched against ip rules and then directed to specific ip table to match ip route rules
1 2 3 4 5 ip rule # output # 0: from all lookup local # 32766: from all lookup main # 32767: from all lookup default these three rules are created by the kernel the number is the matching priority from all means all packets]]></description>
</item>
</channel>
</rss>
